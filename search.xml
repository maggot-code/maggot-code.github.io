<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Go基础-基础结构和类型</title>
      <link href="/2020/05/26/Go%E5%9F%BA%E7%A1%80-%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E5%92%8C%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/05/26/Go%E5%9F%BA%E7%A1%80-%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E5%92%8C%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Go基础结构和类型"><a href="#Go基础结构和类型" class="headerlink" title="Go基础结构和类型"></a>Go基础结构和类型</h2><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><blockquote><p>常量定义使用关键字<code>const</code>，用来保存一些不会改变的数据信息；</p></blockquote><p>在常量中存储的数据类型可以是<code>布尔型、 数字型以及字符串型</code></p><a id="more"></a><p>声明：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> 常量名称 [常量类型] = 常量值</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name <span class="keyword">string</span> = <span class="string">"hooker"</span></span><br></pre></td></tr></table></figure><p>其中<strong>常量类型</strong>是可以省略的，编辑器会根据<strong>赋值</strong>来自己推断类型；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式定义</span></span><br><span class="line"><span class="keyword">const</span> a <span class="keyword">string</span> = <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐式定义</span></span><br><span class="line"><span class="keyword">const</span> a = <span class="string">"abc"</span></span><br></pre></td></tr></table></figure><p><strong>常量的值必须能够在编译时可以确定，常量声明时可以设计到表达式的计算不过所计算的值必须在编译时可以确定获得；</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> c1 = <span class="number">2</span>/<span class="number">3</span> <span class="comment">// 2 和 3 都是在编译时可以确定的值，表达式将结果赋值给常量c1</span></span><br><span class="line"><span class="keyword">const</span> c2 = getSum() <span class="comment">// 调用函数返回值赋值给常量会抛出异常：getNumber() used as value</span></span><br></pre></td></tr></table></figure><p><strong>数字类型的常量并没有大小和符号，所以可以使用任何精度的值，不需要担心溢出问题；</strong></p><p>常量是可以<strong>枚举</strong>的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    b = <span class="number">1</span></span><br><span class="line">    c = <span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>枚举是可以通过<code>iota</code>来进行赋值的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b = <span class="literal">iota</span></span><br><span class="line">    c = <span class="literal">iota</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>第一个<code>iota</code>等于 0 ，每当<code>iota</code>在<strong>新的一行</strong>使用的是时候，值都会自动加一；</p><p>通过<code>iota</code>进行枚举赋值，上面的例子还是写了三个，相当于把<code>0,1,2</code>变成了三个<code>iota</code>；不过可以只在第一行书写一个<code>iota</code>就可以了；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="literal">iota</span></span><br><span class="line">    b</span><br><span class="line">    c</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><strong>注意：<code>iota</code>在每遇到一个新的常量块或者当个常量声明的时候，都会自动重置为 0 （每当<code>iota</code>遇到一个<code>const</code>关键字就会重置）；</strong></p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量通常情况下声明是使用<code>var</code>关键字；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名称 变量类型</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span></span><br></pre></td></tr></table></figure><p>当通过<code>var</code>关键字声明的时候，系统会自动给这个变量赋值一个对应类型的<strong>零值</strong>：</p><ul><li><code>int    =&gt; 0</code></li><li><code>float  =&gt; 0.0</code></li><li><code>bool   =&gt; false</code></li><li><code>string =&gt; 空字符串</code></li><li><code>指针   =&gt; nil</code></li></ul><p><strong>所有的内存在Go中都是经过初始化的</strong></p><h4 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h4><p>变量的命名规则遵循<strong>驼峰命名法</strong>，单词首字母小写，每个新单词首字母大写</p><p>不过如果声明的是一个全局变量，并且希望被外部的其他包所使用，那么需要首个单词的首字母同样大写；</p><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>一个变量、常量、类型以及函数，都是有着自己的<strong>作用范围</strong>的，这个范围就是它们的<strong>作用域</strong>；</p><p>一个变量在函数体的外部声明了，那么这个变量可以被认为是一个<strong>全局变量</strong>，可以在整个包中甚至外部包（被导出的情况下并且遵循可见性原则）使用，不管这个变量被声明在哪个文件中；</p><p>在函数体内部声明的变量则是<strong>局部变量</strong>，作用域仅仅限制在函数体的内部，<strong>参数和返回值</strong>都属于局部变量；</p><p>既然有了作用域，即使变量的声明是唯一的，也可以在某个代码块的内部中使用相同名称的变量来声明；</p><p>当然还存在另一种声明方式，上面这种声明方式通常是在包级别的全局变量的时候使用；而在函数体内部声明的局部变量时，应该使用更加简短的的声明语法<code>:=</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">1</span></span><br></pre></td></tr></table></figure><h4 id="“值”类型和“引用”类型"><a href="#“值”类型和“引用”类型" class="headerlink" title="“值”类型和“引用”类型"></a>“值”类型和“引用”类型</h4><p><code>int、 float、 bool 和 string</code>都属于<strong>值类型</strong>（值类型还包括一些符合类型，数组和结构体）</p><p>那么当通过<code>=</code>等号将一个变量的值赋值给另一个变量的是后续，实际上是对内存中值的一份拷贝赋值给了目标变量；</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j := <span class="number">1</span></span><br><span class="line">i := j</span><br></pre></td></tr></table></figure><p>实际上变量<code>i 和 j</code>的值是相同的，但他们在内存中分别使用了两块区域并且都是独立的。他们有着不同的内存地址。那就意味着，当修改了<code>i</code>的值的时候<code>j</code>的值是不会改变的。因为修改的只是指向变量<code>i</code>的内存地址的那块区域中的值；</p><p>通过<code>&amp;i</code>就可以取得变量<code>i</code>的内存地址，<strong>值类型的变量通常是存储在栈中的</strong>；</p><p>而更复杂一些的数据，通常是<strong>引用类型</strong>保存的；</p><p>这个变量会保存一个值的内存地址；</p><p>内存地址被称为<strong>指针</strong></p><p>引用类型除了<strong>指针</strong>以外还包括<code>slices、 maps、 channel</code>被引用的变量会存储在堆中，是为了方便进行垃圾回收，并且相比栈有着更大的内存空间；</p><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>表达式是一种特定类型的值，它可以由其他的值包括运算符组成；</p><p>并且每个类型都必须和自己可以结合运算的运算符集合；</p><p>并且Go属于强类型语言，在进行计算的时候，是不会进行<strong>隐式转换</strong>的，所以在使用任何值属性进行计算的时候都必须提前显示的说明了它的类型；</p><h4 id="bool"><a href="#bool" class="headerlink" title="bool"></a><code>bool</code></h4><p>布尔型的值只有两种<code>true and false</code></p><p>在两个类型相同的值之间是可以通过<code>== 或者 !=</code>来进行运算的，并且结果会是一个布尔型的值；</p><p>这就涉及到了一个<strong>比较运算符</strong>（与<code>&amp;&amp;</code>、 或<code>||</code>、 非<code>!</code>）；</p><p>Go对于值之间的比较是有严格限制的，只有在两个类型<strong>相同</strong>的值之间才能进行比较，如果值类型是接口（<code>interface</code>），那比较的值也必须实现了相同的接口，如果其中一个值是常量，另一个值的类型也必须和这个常量类型相匹配；</p><h4 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h4><p>数值类型中包含两个：一个是<strong>整形<code>int</code></strong>另一个则是<strong>浮点型<code>float</code></strong>；</p><p>类型的长度都是根据运行程冠希所在的操作系统类型来决定的：</p><ul><li><code>int</code>和<code>uint</code>在32位操作系统上，均是32位（4个字节），而在64位操作系统上，则是64位（8个字节）；</li><li><code>uintptr</code>的长度则被设定为了一个足够存放一个指针的空间；</li></ul><p>在Go语言中没有<code>float类型</code>，也没有<code>double类型</code>。只有<code>float32 和 float64</code></p><p>而一些与操作系统无关的类型都有着固定的长度大小：</p><h5 id="整数："><a href="#整数：" class="headerlink" title="整数："></a>整数：</h5><table><thead><tr><th>类型</th><th>大小</th></tr></thead><tbody><tr><td><code>int8</code></td><td><code>-128 -&gt; 127</code></td></tr><tr><td><code>int16</code></td><td><code>-32768 -&gt; 32767</code></td></tr><tr><td><code>int32</code></td><td><code>-2,147,483,648 -&gt; 2,147,483,647</code></td></tr><tr><td><code>int64</code></td><td><code>-9,223,372,036,854,775,808 -&gt; 9,223,372,036,854,775,807</code></td></tr></tbody></table><h5 id="无符号整数："><a href="#无符号整数：" class="headerlink" title="无符号整数："></a>无符号整数：</h5><table><thead><tr><th>类型</th><th>大小</th></tr></thead><tbody><tr><td><code>uint8</code></td><td><code>0 -&gt; 255</code></td></tr><tr><td><code>uint16</code></td><td><code>0 -&gt; 65,535</code></td></tr><tr><td><code>uint32</code></td><td><code>0 -&gt; 4,294,967,295</code></td></tr><tr><td><code>uint64</code></td><td><code>00 -&gt; 18,446,744,073,709,554,615</code></td></tr></tbody></table><h5 id="浮点型："><a href="#浮点型：" class="headerlink" title="浮点型："></a>浮点型：</h5><table><thead><tr><th>类型</th><th>大小</th></tr></thead><tbody><tr><td><code>float32</code></td><td><code>+-1e-45 -&gt; +-3.4*1e38</code></td></tr><tr><td><code>float64</code></td><td><code>+-5 1e-324 -&gt; 107 1e308</code></td></tr></tbody></table><p>综合上述，<code>int</code>型是计算最快的一种类型；</p><p>整型的零值为<code>0</code>，浮点型的零值为<code>0.0</code>；</p><p><strong><code>float32</code>精度在小数点后7位，<code>float64</code>精度在小数点后15位；</strong></p><h5 id="运算符与优先级"><a href="#运算符与优先级" class="headerlink" title="运算符与优先级"></a>运算符与优先级</h5><p>所有运算方向均为<strong>从左到右</strong>，当然运算符也要是存在优先级的：</p><table><thead><tr><th>优先级</th><th>运算符</th></tr></thead><tbody><tr><td>7</td><td><code>^</code>，<code>!</code></td></tr><tr><td>6</td><td><code>*</code>、<code>/</code>、<code>%</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>&amp;</code>、<code>&amp;^</code></td></tr><tr><td>5</td><td><code>+</code>、<code>-</code>、`</td></tr><tr><td>4</td><td><code>==</code>、<code>!=</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&gt;</code></td></tr><tr><td>3</td><td><code>&lt;-</code></td></tr><tr><td>2</td><td><code>&amp;&amp;</code></td></tr><tr><td>1</td><td>`</td></tr></tbody></table><h4 id="string"><a href="#string" class="headerlink" title="string"></a><code>string</code></h4><p>Go中的字符串是根据需求占用1到4个字节的（Java始终占用2个字节）；</p><p>字符串是一种值类型，<strong>并且值不可变</strong>，创建某个文本后则无法再次修改这个文本的内容；（？？？）</p><p><strong>剖析的讲字符串就是字节的定长数组；</strong></p><p>Go在声明字符串的时候支持两种字面量的方式：</p><ul><li><p>解释字符串</p><p>该方式字符串使用双引号括起来，其中的相关转义字符也会被替换：</p><ul><li><code>\n</code> ： 换行符</li><li><code>\r</code> ： 回车符</li><li><code>\t</code> ： 制表符</li><li><code>\u</code> ： Unicode字符</li><li><code>\\</code> ： 表示转义反斜杠本身</li></ul></li><li><p>非解释字符串</p><p>该方式字符串通过使用反引号括起来<code>``</code>，并且支持换行</p></li></ul><p><code>string</code>类型的零值表示为长度为零的字符串，也就是空字符串<code>&quot;&quot;</code>；</p><h4 id="错误类型"><a href="#错误类型" class="headerlink" title="错误类型"></a>错误类型</h4>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自用 </tag>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go基础-基本概念</title>
      <link href="/2020/05/26/Go%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2020/05/26/Go%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="Golang基础概念"><a href="#Golang基础概念" class="headerlink" title="Golang基础概念"></a>Golang基础概念</h2><h3 id="Go环境变量"><a href="#Go环境变量" class="headerlink" title="Go环境变量"></a>Go环境变量</h3><h4 id="GOROOT"><a href="#GOROOT" class="headerlink" title="$GOROOT"></a><code>$GOROOT</code></h4><p>表示Go在电脑上的安装位置，通常情况下都是在（windows为例）<code>%USERPROFILE%/go</code>，不过也可以安装在其他位置；</p><a id="more"></a><h4 id="GOARCH"><a href="#GOARCH" class="headerlink" title="$GOARCH"></a><code>$GOARCH</code></h4><p>表示目标机器的处理器架构；</p><h4 id="GOOS"><a href="#GOOS" class="headerlink" title="$GOOS"></a><code>$GOOS</code></h4><p>表示目标机器的操作系统，它的值可以是<code>darwin, freebsd, linux 或者 windows</code></p><h4 id="GOBIN"><a href="#GOBIN" class="headerlink" title="$GOBIN"></a><code>$GOBIN</code></h4><p>表示编译器和链接器的安装位置，默认情况下为<code>$GOROOT/bin</code>；如果正在使用的Go版本为<code>1.0.3+</code>，那么一般情况下<code>$GOBIN</code>的值是可以设置为<strong>空</strong>的，它会自己使用前面提到的默认值；</p><blockquote><p>提到的目标机器都是指的打算运行Go应用程序的机器；</p><p>因为Go编译器是支持<strong>交叉编译</strong>的，也就是说可以在一台机器上构建运行在具有不同操作系统和处理器架构上的应用程序，就是说编写源代码的机器可以和目标机有着完全不同的特性（操作系统和处理器架构）</p><p>不过为了区分本地机器和目标机器，需要使用<code>$GOHOSTOS</code> 和 <code>$GOHOSTARCH</code> 设置本地机器的操作系统名称和编译体系结构；不过这两个变量仅仅实在进行交叉编译的时候才会用到，如果不进行过显示的设置，那么值则会和目标机器的（<code>$GOOS</code> 和 <code>$GOARCH</code>）相同；</p></blockquote><h4 id="GOPATH"><a href="#GOPATH" class="headerlink" title="$GOPATH"></a><code>$GOPATH</code></h4><p>默认情况下它的值是和<code>$GOROOT</code>相同的，不过从<code>GO 1.1版本</code>开始，就必须要修改为其他路径；它可以包含多个有着Go语言源码文件、包文件和可执行文件的路径，这些路径下必须包含<strong>三个规定目录：</strong><code>src(源码文件)</code> 、 <code>pkg(包文件)</code> 、 <code>bin(可执行文件)</code>；</p><h4 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="$GOMAXPROCS"></a><code>$GOMAXPROCS</code></h4><p>表示应用程序可以使用的处理器个数与核数；</p><h4 id="GOROOT目录下应该包含的文件夹结构："><a href="#GOROOT目录下应该包含的文件夹结构：" class="headerlink" title="$GOROOT目录下应该包含的文件夹结构："></a><code>$GOROOT</code>目录下应该包含的文件夹结构：</h4><ul><li><code>/bin</code> ： 包含可执行文件；</li><li><code>/doc</code> ： 包含例子程序，代码工具以及本地文档；</li><li><code>/lib</code> ： 包含文档模板；</li><li><code>/misc</code> ： 包含支持Go编辑器有关的配置文件；</li><li><code>/os_arch</code> ： 包含标准库的包对象文件（<code>.a</code>）；</li><li><code>/src</code> ： 包含构建源代码的脚本以及一些自带标准库的包的源代码；</li><li><code>/src/cmd</code> ： 包含Go和C的编译器和命令行控制脚本；</li></ul><h3 id="Go调试方法"><a href="#Go调试方法" class="headerlink" title="Go调试方法"></a>Go调试方法</h3><ol><li>通过使用<code>print / println</code> 和 <code>fmt.Print / fmt.Println / fmt.Printf</code>打印语句进行输出一些变量的值；</li><li><code>fmt.Printf</code>中可以通过一些<strong>说明符</strong>打印有关输出值的更多信息：<ul><li><code>%+v</code>输出字段内的实例的完整信息；</li><li><code>%#v</code>输出字段和类型名称</li><li><code>%T</code>  输出某个类型</li></ul></li><li>还可以使用<code>panic</code>语句获取栈追踪信息；</li><li>以及使用<code>defer</code>关键字追踪代码执行过程；</li></ol><h3 id="文档生成"><a href="#文档生成" class="headerlink" title="文档生成"></a>文档生成</h3><p><code>go doc</code>工具可以从Go程序和包文件中提取顶级声明的首行注释以及每个对象的相关注释，生成相关文档；</p><ul><li><code>go doc package</code> 获取包的文档注释；</li><li><code>go doc package/subpackage</code> 获取子包的文档注释；</li><li><code>go doc package function</code> 获取某个函数在某个包中的文档注释；</li></ul><p><code>go doc</code>工具只能获取**安装目录下的<code>../go/src</code>中的注释内容；</p><p>还可以通过命令<code>godoc -http=:8848</code>，在本地启动一个文档服务器；</p><h3 id="“包”的概念"><a href="#“包”的概念" class="headerlink" title="“包”的概念"></a>“包”的概念</h3><p><strong>包</strong>是Go语言中<strong>结构化代码</strong>的一种方法，有点类似其他语言中的库或命名空间，每个Go文件都<strong>属于并且仅属于一个包</strong>。而且一个包是可以由多个Go源文件组成的；</p><p>每个程序都应该包含且包含一个<code>main</code>包；</p><p>程序能由不同的包组成，并且没有必要把所有的代码都写在一个文件中；可以通过多个文件组成一个包；</p><p><strong>注意：所有的包名都应该使用小写字母；</strong></p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>当<code>常量、 变量、 类型、 函数名、 结构字段等等</code>这些都以一个<strong>大写字母</strong>开头，那么这些标识符对象是可以被外部包中的代码所使用的；有点像<code>public？</code>；</p><p>而如果是小写字母开头的话，则表示对外部的包不可见，仅仅可以在当前包的内部使用；<code>private？</code></p><p><strong>*注意：如果导入了一个包，而没有使用Go语言则会在编译时抛出一个异常<code>imported and not used: xxx</code>；</strong></p><h3 id="程序执行过程"><a href="#程序执行过程" class="headerlink" title="程序执行过程"></a>程序执行过程</h3><img src="/2020/05/26/Go%E5%9F%BA%E7%A1%80-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2.3.init.png" class="" title="This is an 2.3.init.png image">]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自用 </tag>
            
            <tag> GoLang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown使用基础</title>
      <link href="/2020/04/07/MarkDown%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/"/>
      <url>/2020/04/07/MarkDown%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong><code>MarkDown</code></strong>是一款轻量级的<strong>「标记语言」</strong>，通过使用一些比较简单的<strong>标记符号</strong>来代替一些常见的文章排版格式，并且提供给了<strong>编辑表格</strong>，<strong>插入图片</strong>以及可以制作<strong>一些简单的思维导图</strong>，并且可以轻松导出<code>HTML、PDF、</code></p><a id="more"></a><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><blockquote><p>首先对于文章来说第一个需要用到的肯定是<strong>标题</strong>了；</p><p><code>markdown</code>就提供了对于标题的基本使用；</p><p><code>markdown</code>的标题有两个方式：</p><p>一种是通过使用<code>=</code>和<code>-</code>里标记一级和二级标题</p><p>另一种则是通过<code>#</code>号来进行标记</p></blockquote><h3 id="通过-和-来定义标题"><a href="#通过-和-来定义标题" class="headerlink" title="通过=和-来定义标题"></a>通过<code>=</code>和<code>-</code>来定义标题</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一级标题</span><br><span class="line">========</span><br><span class="line"></span><br><span class="line">二级标题</span><br><span class="line">-------</span><br></pre></td></tr></table></figure><h3 id="通过-号来定义标题"><a href="#通过-号来定义标题" class="headerlink" title="通过#号来定义标题"></a>通过<code>#</code>号来定义标题</h3><blockquote><p>使用<code>#</code>号其实就是对应着<code>HTML</code>中的<code>h1、h2、...h6</code>等标签；</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题h1</span></span><br><span class="line"><span class="section">## 二级标题h2</span></span><br><span class="line"><span class="section">### 三级标题h3</span></span><br><span class="line"><span class="section">#### 四级标题h4</span></span><br><span class="line"><span class="section">##### 五级标题h5</span></span><br><span class="line"><span class="section">###### 六级标题h6</span></span><br></pre></td></tr></table></figure><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><blockquote><p><strong>段落</strong>其实就是文章的主体部分了，主要来定义多数的内容，当然还包括<strong>字体</strong>的设置，还有<strong>分割线</strong>、<strong>删除线</strong>以及<strong>下划线</strong>；然后就是一些<strong>脚注</strong>，可以用来对某一段的文本进行详细的说明，也是十分有用；</p></blockquote><h3 id="字体设置"><a href="#字体设置" class="headerlink" title="字体设置"></a>字体设置</h3><blockquote><p><code>markdown</code>提供了几种字体的设置</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体文字*</span></span><br><span class="line"></span><br><span class="line"><span class="emphasis">_斜体文字_</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**粗体文字**</span></span><br><span class="line"></span><br><span class="line"><span class="strong">__粗体文字__</span></span><br><span class="line"></span><br><span class="line"><span class="strong">***粗斜体文字**</span>*</span><br><span class="line"></span><br><span class="line"><span class="strong">___粗斜体文字__</span>_</span><br></pre></td></tr></table></figure><h3 id="分割线、删除线和下划线"><a href="#分割线、删除线和下划线" class="headerlink" title="分割线、删除线和下划线"></a>分割线、删除线和下划线</h3><ol><li><p><strong>删除线：</strong></p><p>如果在编写段落的时候，可以通过使用在需要设置删除线的文字两端加上<code>~~</code>两个波浪线就可做到了；</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">哈哈哈哈哈哈哈哈</span><br><span class="line">嘿嘿嘿嘿嘿嘿嘿嘿</span><br><span class="line">~~歪比歪比歪比巴卜~~</span><br></pre></td></tr></table></figure></li><li><p><strong>下划线：</strong></p><p>设置文本的下划线是需要通过使用<code>HTML</code>的<code>&lt;u&gt;</code>标签来实现的；</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>需要添加下划线的内容<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li><p><strong>分割线：</strong></p><p>分割线是需要在一行中使用三个以上的星号、减号或者<code>----</code>来建立一条分割线；</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">分割线</span><br><span class="line"><span class="strong">*****</span></span><br><span class="line">分割线</span><br><span class="line">-----</span><br></pre></td></tr></table></figure></li></ol><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><blockquote><p>脚注是用来对一段文字进行说明使用的；</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^说明内容]</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><blockquote><p><code>markdown</code>是支持<strong>有序</strong>和<strong>无序</strong>列表的；</p></blockquote><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><blockquote><p>无序列表是使用<strong>星号(*)</strong>、<strong>加号(+)</strong>或者<strong>减号(-)</strong>来做无序列表的标记的；</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span>列表一</span><br><span class="line"><span class="bullet">* </span>列表二</span><br><span class="line"><span class="bullet">* </span>列表三</span><br><span class="line"></span><br><span class="line"><span class="bullet">+ </span>列表一</span><br><span class="line"><span class="bullet">+ </span>列表二</span><br><span class="line"><span class="bullet">+ </span>列表三</span><br><span class="line"></span><br><span class="line"><span class="bullet">- </span>列表一</span><br><span class="line"><span class="bullet">- </span>列表二</span><br><span class="line"><span class="bullet">- </span>列表三</span><br></pre></td></tr></table></figure><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><blockquote><p>有序列表则是需要使用数字并且加上<code>.</code>号表示的；</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>列表一</span><br><span class="line"><span class="bullet">2. </span>列表二</span><br><span class="line"><span class="bullet">3. </span>列表三</span><br></pre></td></tr></table></figure><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><blockquote><p>列表是可以形成一种嵌套关系的，例如在有序列表中使用无序列表，形成一个二级列表的关系；</p><p>二级列表需要在使用标记前添加<strong>四个空格</strong>；</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>列表一</span><br><span class="line"><span class="bullet">    * </span>1111111111</span><br><span class="line"><span class="bullet">    * </span>2222222222</span><br><span class="line"><span class="bullet">2. </span>列表二</span><br><span class="line"><span class="bullet">    * </span>3333333333</span><br><span class="line"><span class="bullet">    * </span>4444444444</span><br></pre></td></tr></table></figure><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><blockquote><p>有些时候需要在文章中加入一些代码片段，有两种方式；</p><ul><li>使用<strong>( ` )</strong>反引号，把需要的代码片段包裹起来，但是这种方式只适用于一行内的文字；</li><li>使用三个<strong>( ``` )</strong>反引号，把代码片段包起来，这种方式是适用于多行文字的；</li></ul></blockquote><h3 id="单个反引号"><a href="#单个反引号" class="headerlink" title="单个反引号"></a>单个反引号</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`需要的单行代码片段`</span></span><br></pre></td></tr></table></figure><h3 id="三个反引号"><a href="#三个反引号" class="headerlink" title="三个反引号"></a>三个反引号</h3><blockquote><p>使用三个反引号的时候，是可以来指定这个代码块使用的是什么语言的，例如<code>javascript</code>、<code>php</code>、<code>python</code>等等，会根据不同语言的语法进行高亮的显示和代码的缩进，当然也是支持一些其他的，例如<code>markdown</code>；</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">functiton test()&#123;</span><br><span class="line"><span class="code">alert('hello markdown');</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><blockquote><p>主要链接可以分为两种</p><ul><li>一种是直接在文章段落内部，直接嵌入的</li><li>另一种则是通过在文章段落中使用别名进行嵌入，然后在整个文章的末尾进行规整</li></ul></blockquote><h3 id="普通链接"><a href="#普通链接" class="headerlink" title="普通链接"></a>普通链接</h3><blockquote><p>普通的在文章段落内部直接嵌入的方式如下：</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">链接名称</span>](<span class="link">链接地址</span>)</span><br><span class="line"></span><br><span class="line">或者是</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">链接地址</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这两种方式第一种则是可以在文章中显示一个别名（别名写在<code>[]</code>中），然后点击可以跳转到<code>()</code>的地址去；</p><p>另一个是会直接将地址显示在文章中；</p><h3 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h3><blockquote><p>这种方式可以使用类似变量的东西来设置一个链接的地址，可以把整个文章中所有的链接都规整都一个地方，方便日后的修改和管理；</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">第一个链接[<span class="string">baidu</span>][<span class="symbol">baidu</span>]</span><br><span class="line">第二个链接[<span class="string">博客</span>][<span class="symbol">blog</span>]</span><br><span class="line"></span><br><span class="line">[<span class="symbol">baidu</span>]: <span class="link">http://www.baidu.com</span></span><br><span class="line">[<span class="symbol">blog</span>]: <span class="link">https://maggot-code.github.io</span></span><br></pre></td></tr></table></figure><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><blockquote><p><code>markdown</code>提供了三种插入图片的方式：</p><ol><li>默认模式下，可以直接在文章中进行图片的插入</li><li>可以像链接的高级链接一样，通过使用类似变量的方式插入，并在具体的一个地方来规整所有的图片链接</li><li>通过使用普通的<code>HTML</code>中的<code>&lt;img&gt;</code>标签来插入一张图片</li></ol></blockquote><h3 id="默认模式下的图片插入"><a href="#默认模式下的图片插入" class="headerlink" title="默认模式下的图片插入"></a>默认模式下的图片插入</h3><ul><li>开头需要存在一个感叹号<code>!</code></li><li>接着是一个方括号<code>[]</code>，方括号中写入图片的代替文字</li><li>然后是一个普通的括号<code>()</code>，里面写入图片的地址，还可以在地址后面加上一个空格，在填入一个图片的<code>title</code>属性；</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">图片1</span>](<span class="link">图片1地址</span>)</span><br><span class="line">![<span class="string">图片2</span>](<span class="link">图片2地址 title文字</span>)</span><br></pre></td></tr></table></figure><h3 id="使用类似变量方式来插入图片"><a href="#使用类似变量方式来插入图片" class="headerlink" title="使用类似变量方式来插入图片"></a>使用类似变量方式来插入图片</h3><p>可以像类似链接中的高级链接一样，将所有的图片信息规整到一起，然后通过一个类似变量的设置来进行引用</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这里是一张图片[<span class="string">images</span>](<span class="link">img</span>)</span><br><span class="line"></span><br><span class="line">[<span class="symbol">img</span>]: <span class="link">http://xxx.xxx.com/images/xxx.jpeg</span></span><br></pre></td></tr></table></figure><p>这样则是可以通过地址的方式来插入一张图片，不过它是不会显示在文章中的，代替的位置则会出现方括号<code>[]</code>中的文字内容，点击可以打开一张图片；</p><h3 id="使用-lt-img-gt-标签插入图片"><a href="#使用-lt-img-gt-标签插入图片" class="headerlink" title="使用&lt;img&gt;标签插入图片"></a>使用<code>&lt;img&gt;</code>标签插入图片</h3><blockquote><p>在<code>markdown</code>中，插入的图片是没有办法调整大小的，所以如果需要对插入的图片大小进行调整，是可a以直接使用<code>HTML</code>中的<code>&lt;img&gt;</code>标签的；</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://xxx.xxx.com/images/xxx.jpeg"</span> <span class="attr">width</span>=<span class="string">"200px"</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><blockquote><p><code>markdown</code>中制作表格是使用<code>|</code>对单元格进行分割的，然后使用<code>-</code>分割表头和表内容；</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 表头 | 表头 |</span><br><span class="line">| ---- | ---- |</span><br><span class="line">| 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 |</span><br></pre></td></tr></table></figure><p>如果需要设置<strong>对齐方式</strong>：</p><ul><li><code>-:</code>设置内容和标题右对齐</li><li><code>:-</code>设置内容和标题左对齐</li><li><code>:-:</code>设置标题和内容居中对齐</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure><h2 id="一些高级技巧"><a href="#一些高级技巧" class="headerlink" title="一些高级技巧"></a>一些高级技巧</h2><h3 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h3><blockquote><p>目前<code>markdown</code>是支持<code>HTML</code>元素的，不过是少量的，支持的元素如下：</p><p><code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt; &lt;img&gt;</code></p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>+<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Alt<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>+<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Del<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> 重启电脑</span><br></pre></td></tr></table></figure><h3 id="绘制流程、时序图"><a href="#绘制流程、时序图" class="headerlink" title="绘制流程、时序图"></a>绘制流程、时序图</h3><blockquote><p><code>markdown</code>目前是可以绘制一些简单的流程图、时序图等等的；</p><p>需要使用代码块的方式来载入，关键字是<code>mermaid</code>、<code>flow</code>、<code>sequence</code></p><p>下面是一些简单的例子：</p></blockquote><h4 id="横向流程图"><a href="#横向流程图" class="headerlink" title="横向流程图"></a>横向流程图</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line"><span class="code">    B --&gt; C&#123;条件a&#125;</span></span><br><span class="line"><span class="code">    C --&gt;|a=1| D[结果1]</span></span><br><span class="line"><span class="code">    C --&gt;|a=2| E[结果2]</span></span><br><span class="line"><span class="code">    F[横向流程图]</span></span><br></pre></td></tr></table></figure><img src="/2020/04/07/MarkDown%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/liuchengtu-heng.png" class="" title="This is an liuchengtu-heng.png image"><h4 id="竖向流程图"><a href="#竖向流程图" class="headerlink" title="竖向流程图"></a>竖向流程图</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line"><span class="code">    B --&gt; C&#123;条件a&#125;</span></span><br><span class="line"><span class="code">    C --&gt; |a=1| D[结果1]</span></span><br><span class="line"><span class="code">    C --&gt; |a=2| E[结果2]</span></span><br><span class="line"><span class="code">    F[竖向流程图]</span></span><br></pre></td></tr></table></figure><img src="/2020/04/07/MarkDown%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/liuchengtu-shu.png" class="" title="This is an liuchengtu-shu.png image"><h4 id="标准流程图"><a href="#标准流程图" class="headerlink" title="标准流程图"></a>标准流程图</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><img src="/2020/04/07/MarkDown%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/liuchengtu-shu-biaozhun.png" class="" title="This is an liuchengtu-shu-biaozhun.png image"><h4 id="标准流程图（横向）"><a href="#标准流程图（横向）" class="headerlink" title="标准流程图（横向）"></a>标准流程图（横向）</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><img src="/2020/04/07/MarkDown%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/liuchengtu-heng-biaozhun.png" class="" title="This is an liuchengtu-heng-biaozhun.png image"><h4 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br></pre></td></tr></table></figure><img src="/2020/04/07/MarkDown%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/shuxutu.png" class="" title="This is an shuxutu.png image"><h4 id="比较负责的时序图"><a href="#比较负责的时序图" class="headerlink" title="比较负责的时序图"></a>比较负责的时序图</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Title: 标题：复杂使用</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br></pre></td></tr></table></figure><img src="/2020/04/07/MarkDown%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/shuxutu-fuza.png" class="" title="This is an shuxutu-fuza.png image"><h4 id="甘特图"><a href="#甘特图" class="headerlink" title="甘特图"></a>甘特图</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%% 语法示例</span><br><span class="line"><span class="code">        gantt</span></span><br><span class="line"><span class="code">        dateFormat  YYYY-MM-DD</span></span><br><span class="line"><span class="code">        title 软件开发甘特图</span></span><br><span class="line"><span class="code">        section 设计</span></span><br><span class="line"><span class="code">        需求                      :done,    des1, 2014-01-06,2014-01-08</span></span><br><span class="line"><span class="code">        原型                      :active,  des2, 2014-01-09, 3d</span></span><br><span class="line"><span class="code">        UI设计                     :         des3, after des2, 5d</span></span><br><span class="line"><span class="code">    未来任务                     :         des4, after des3, 5d</span></span><br><span class="line"><span class="code">        section 开发</span></span><br><span class="line"><span class="code">        学习准备理解需求                      :crit, done, 2014-01-06,24h</span></span><br><span class="line"><span class="code">        设计框架                             :crit, done, after des2, 2d</span></span><br><span class="line"><span class="code">        开发                                 :crit, active, 3d</span></span><br><span class="line"><span class="code">        未来任务                              :crit, 5d</span></span><br><span class="line"><span class="code">        耍                                   :2d</span></span><br><span class="line"><span class="code">        section 测试</span></span><br><span class="line"><span class="code">        功能测试                              :active, a1, after des3, 3d</span></span><br><span class="line"><span class="code">        压力测试                               :after a1  , 20h</span></span><br><span class="line"><span class="code">        测试报告                               : 48h</span></span><br></pre></td></tr></table></figure><img src="/2020/04/07/MarkDown%E4%BD%BF%E7%94%A8%E5%9F%BA%E7%A1%80/gantetu.png" class="" title="This is an gantetu.png image">]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自用 </tag>
            
            <tag> MarkDown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git版本控制的理解</title>
      <link href="/2020/04/07/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2020/04/07/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前记录过<code>Git的基础使用</code></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自用 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git基础使用</title>
      <link href="/2020/04/05/Git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
      <url>/2020/04/05/Git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="Git使用基础"><a href="#Git使用基础" class="headerlink" title="Git使用基础"></a>Git使用基础</h2><h3 id="首先要明确Git的分区概念"><a href="#首先要明确Git的分区概念" class="headerlink" title="首先要明确Git的分区概念"></a>首先要明确Git的分区概念</h3><ul><li><strong>工作区：</strong>就是在本地电脑中能看到的正在使用的目录</li><li><strong>暂存区：</strong>英文叫<code>stage</code>或者是<code>index</code>，一般存在放<code>.git</code>目录下的<code>index</code>文件中<code>(.git / index)</code>，所以我们把暂存区有时候也叫做<strong>索引(index)</strong></li><li><strong>版本库：</strong>工作区里有一个隐藏的目录<code>.git</code>，这个不算工作区，而是<code>Git的版本库</code><a id="more"></a></li></ul><h3 id="配置Git的相关参数"><a href="#配置Git的相关参数" class="headerlink" title="配置Git的相关参数"></a>配置<code>Git</code>的相关参数</h3><p><strong>command：</strong></p><p><code>git config</code></p><h4 id="Git一共有三个配置文件："><a href="#Git一共有三个配置文件：" class="headerlink" title="Git一共有三个配置文件："></a>Git一共有三个配置文件：</h4><ol><li>仓库级的配置文件：在仓库的<code>.git / .gitconfig</code>，该配置文件只对所在的仓库有效；</li><li>全局配置文件：Mac系统在<code>~/.gitconfig</code>，Windows系统在<code>C:\users\&lt;用户名&gt;\.gitconfig</code></li><li>系统级的配置文件：在<code>Git</code>的安装目录下（Mac系统下安装目录在<code>/usr/local/git</code>）的<code>etc</code>文件夹中的<code>gitconfig</code></li></ol><p><strong>explain：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看配置信息</span></span><br><span class="line"><span class="comment">// --local:仓库级， --global:全局级, --system:系统级</span></span><br><span class="line">$ git config &lt; --local | --global | --system &gt; -l</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看当前生效的配置信息</span></span><br><span class="line">$ git config -l</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编辑配置文件</span></span><br><span class="line">$ git config &lt; --local | --global | --system &gt; -e</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加配置项</span></span><br><span class="line">$ git config &lt; --local | --global | --system &gt; --add name value</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除配置项</span></span><br><span class="line">$ git config &lt; --local | --global | --system &gt; --unset name</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取配置项</span></span><br><span class="line">$ git config &lt; --local | --global | --system &gt; --<span class="keyword">get</span> name</span><br><span class="line"></span><br><span class="line">// 配置提交记录中的用户信息</span><br><span class="line">$ git config --global user.name 用户名</span><br><span class="line">$ git config --global user.email 邮箱地址</span><br><span class="line"></span><br><span class="line">// 调用 git status / git diff 命令时候以高亮或彩色方式显示改动状态</span><br><span class="line">$ git config --global color.ui true</span><br></pre></td></tr></table></figure><h3 id="查看本地仓库状态"><a href="#查看本地仓库状态" class="headerlink" title="查看本地仓库状态"></a>查看本地仓库状态</h3><p><strong>command：</strong></p><p><code>git status</code></p><p><strong>explain：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看本地仓库状态</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">说明下面的git-use.md 和 test.js 是未追踪的状态，目前还是处于工作区当中;</span></span><br><span class="line"><span class="comment">Untracked files:</span></span><br><span class="line"><span class="comment">  (use "git add &lt;file&gt;..." to include in what will be committed)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        git-ues.md</span></span><br><span class="line"><span class="comment">        test.js</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以简短模式查看本地仓库的状态</span></span><br><span class="line"><span class="comment">// 会显示两列,第一列是文件的状态，第二列是对应的文件</span></span><br><span class="line"><span class="comment">// 文件状态：A 新增，M 修改， D 删除， ?? 未添加至Git中</span></span><br><span class="line">$ git status -s</span><br></pre></td></tr></table></figure><h3 id="添加到暂存区"><a href="#添加到暂存区" class="headerlink" title="添加到暂存区"></a>添加到暂存区</h3><blockquote><p>把要提交的文件的信息添加到<strong>暂存区</strong>中，当使用<code>git commit</code>的时候，将会依据暂存区中的内容进行文件的提交</p></blockquote><p><strong>command：</strong></p><p><code>git add</code></p><p><strong>explain：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把指定的文件添加到暂存区中</span></span><br><span class="line">$ git add 文件路径</span><br><span class="line"></span><br><span class="line">$ git add . <span class="comment">// 一个点就是当前目录中的全部文件添加到暂存区中</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Changes to be committed:</span></span><br><span class="line"><span class="comment">  (use "git reset HEAD &lt;file&gt;..." to unstage)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        new file:   git-use.md</span></span><br><span class="line"><span class="comment">        new file:   test.js</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加所有修改、已删除的文件到暂存区中</span></span><br><span class="line">$ git add -u [ 文件路径 ]</span><br><span class="line">$ git add --update [ 文件路径 ]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加所有修改、已删除、新增的文件到暂存区中,省却 &lt;文件路径&gt; 即为当前目录</span></span><br><span class="line">$ git add -A [ 文件路径 ]</span><br><span class="line">$ git add --all [ 文件路径 ]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看所有的修改、已删除但没有提交的文件,进入一个子命令系统</span></span><br><span class="line">$ git add -i [ 文件路径 ]</span><br><span class="line">$ git add --interactive [ 文件路径 ]</span><br></pre></td></tr></table></figure><h3 id="提交到本地仓库"><a href="#提交到本地仓库" class="headerlink" title="提交到本地仓库"></a>提交到本地仓库</h3><blockquote><p>将<strong>暂存区</strong>中的文件提交到<strong>本地仓库</strong>中去</p></blockquote><p><strong>command：</strong></p><p><code>git commit</code></p><p><strong>explain：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把暂存区中的文件提交到本地仓库</span></span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把暂存区中的文件提交到本地仓库中并添加对本次添加的描述信息</span></span><br><span class="line">$ git commit -m <span class="string">"提交的描述信息"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[master 0fa489e] 2020年4月5日14:31:23我的第一次git提交</span></span><br><span class="line"><span class="comment"> 2 files changed, 67 insertions(+)</span></span><br><span class="line"><span class="comment"> create mode 100644 git-use.md</span></span><br><span class="line"><span class="comment"> create mode 100644 test.js</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把所有修改、已删除的文件提交到本地仓库中</span></span><br><span class="line"><span class="comment">// 不包括未被版本库跟踪的文件,等于先调用了 "git add -u"</span></span><br><span class="line">$ git commit -a -m <span class="string">"提交的描述信息"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改上次提交的描述信息</span></span><br><span class="line">$ git commit --amend</span><br></pre></td></tr></table></figure><blockquote><p>如果是第一次提交的话，会出现如下提示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Please tell me who you are.</span><br><span class="line"></span><br><span class="line">Run</span><br><span class="line"></span><br><span class="line">git config --global user.email <span class="string">"you@example.com"</span></span><br><span class="line">git config --global user.name <span class="string">"Your Name"</span></span><br></pre></td></tr></table></figure><p>提示上说<strong>请告诉他你是谁？</strong>是因为我们还没有设置所以可以执行下面的命令<code>git config</code>中的命令</p></blockquote><h3 id="显示提交记录"><a href="#显示提交记录" class="headerlink" title="显示提交记录"></a>显示提交记录</h3><p><strong>command：</strong></p><p><code>git log</code></p><p><strong>explain：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印所有的提交记录</span></span><br><span class="line">$ git log</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印从第一次提交到指定的提交记录</span></span><br><span class="line">$ git log commit ID</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印指定数量的最新提交记录</span></span><br><span class="line">$ git log -指定的数量</span><br></pre></td></tr></table></figure><h3 id="显示某次提交的详情"><a href="#显示某次提交的详情" class="headerlink" title="显示某次提交的详情"></a>显示某次提交的详情</h3><p><strong>command：</strong></p><p><code>git show commitID</code></p><p><strong>explain：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示提交的指定的详情，指定commit的id</span></span><br><span class="line">$ git show commitID</span><br></pre></td></tr></table></figure><h3 id="还原提交记录"><a href="#还原提交记录" class="headerlink" title="还原提交记录"></a>还原提交记录</h3><p><strong>command：</strong></p><p><code>git reset</code></p><p><strong>explain：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重置暂存区，但是文件不会受到影响</span></span><br><span class="line"><span class="comment">// 相当于将使用 “ git add ” 命令更新到暂存区的内容撤出暂存区,也可以指定文件</span></span><br><span class="line"><span class="comment">// 没有制定个 commit ID 则默认为当前的 HEAD</span></span><br><span class="line">$ git reset [ 文件路径 ]</span><br><span class="line">$ git reset --mixeed [ 文件路径 ]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 HEAD 的指向改变,撤销到指定的提交记录,文件未修改</span></span><br><span class="line">$ git reset commitID</span><br><span class="line">$ git reset --mixed commitID</span><br></pre></td></tr></table></figure><h3 id="推送到远端仓库"><a href="#推送到远端仓库" class="headerlink" title="推送到远端仓库"></a>推送到远端仓库</h3><p><strong>command：</strong></p><p><code>git push</code></p><p><strong>explain：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把本地仓库的分支推送到远端仓库的指定分支</span></span><br><span class="line">$ git push 远端仓库的别名 本地分支名:远端分支名</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定的远端仓库分支</span></span><br><span class="line">$ git push 远端仓库的别名:远端分支名</span><br><span class="line">$ git push 远端仓库的别名 --<span class="keyword">delete</span> 远端分支名</span><br></pre></td></tr></table></figure><h3 id="克隆一个版本"><a href="#克隆一个版本" class="headerlink" title="克隆一个版本"></a>克隆一个版本</h3><p><strong>command：</strong></p><p><code>git clone</code></p><p><strong>explain：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认在当前目录下创建和版本库名相同的文件名并下载版本到该文件夹下</span></span><br><span class="line">$ git clone 远端仓库的地址</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定本地仓库的目录</span></span><br><span class="line">$ git clone 远程仓库的地址 本地目录</span><br><span class="line"></span><br><span class="line"><span class="comment">// -b 指定要克隆的分支,默认是master分支</span></span><br><span class="line">$ git clone 远端仓库的地址 -b 分支名称 本地目录</span><br></pre></td></tr></table></figure><h3 id="如何解决冲突"><a href="#如何解决冲突" class="headerlink" title="如何解决冲突"></a>如何解决冲突</h3><p>在远端仓库已经更新的情况下，在本地仓库进行修改之后再次使用<code>git add .</code>然后<code>git commit -m &quot;修改&quot;</code>和<code>git push</code>的时候会出现如下的提示错误：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">To github.com:maggot-code/hello-git.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to <span class="string">'git@github.com:maggot-code/hello-git.git'</span></span><br><span class="line">hint: Updates were rejected because the remote contains work that you <span class="keyword">do</span></span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., <span class="string">'git pull ...'</span>) before pushing again.</span><br><span class="line">hint: See the <span class="string">'Note about fast-forwards'</span> <span class="keyword">in</span> <span class="string">'git push --help'</span> <span class="keyword">for</span> details.</span><br></pre></td></tr></table></figure><p>上面解释说到，本次提交到<code>github.comm:maggot-code/hello-git.git</code>是失败的，提示说到本次的更新被拒绝了，因为远程包含您现在所做的工作，就是说你修改的地方或者文件远端的仓库也被其他人修改了；而这次修改在本地仓库是没有的，他是由另一个存储仓库所推送的；所以如果希望对远端的更改，需要先使用<code>git pull</code>命令然后在进行推送；</p><h3 id="从远程仓库获取最新包版本并合并到版本地"><a href="#从远程仓库获取最新包版本并合并到版本地" class="headerlink" title="从远程仓库获取最新包版本并合并到版本地"></a>从远程仓库获取最新包版本并合并到版本地</h3><p><strong>command：</strong></p><p><code>git pull</code></p><p><strong>explain：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// git pull会首先执行 git fetch 然后执行了 git merge ，把获取的分支的HEAD合并到当前分支</span></span><br><span class="line">$ git pull</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Auto-merging test.js</span></span><br><span class="line"><span class="comment">CONFLICT (content): Merge conflict in test.js</span></span><br><span class="line"><span class="comment">Automatic merge failed; fix conflicts and then commit the result.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在执行完命令之后因为存在冲突的关系，会看到以后的提示信息：</p><p>说自动合并了<code>test.js</code>文件</p><p>冲突的内容是在<code>test.js</code>中合并了</p><p>并且自动的合并失败了，需要我们来修复冲突，然后提交结果；那么打开<code>test.js</code>文件来查看一下，出现了哪些冲突？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello git'</span>);</span><br><span class="line"><span class="keyword">let</span> a = <span class="string">"我自己的操作"</span></span><br><span class="line">=======</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello update'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello gitsssss'</span>);</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; <span class="number">0706</span>cb2bee45a8a9daaf11e2b585beb8ac8c6060</span><br></pre></td></tr></table></figure><p>可以看到<strong>git</strong>是通过向<code>====</code>来区别冲突的地方，而等号上面则是自己冲突的地方，而下面的则是另一个仓库生产的冲突，这个时候就需要和提交冲突的人，也就是同事，来商量是我的有用，还是你的有用；那么如果都有用，则可以直接把所有的箭头和等号都删除变成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello git'</span>);</span><br><span class="line"><span class="keyword">let</span> a = <span class="string">"我自己的操作"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello update'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello gitsssss'</span>);</span><br></pre></td></tr></table></figure><p>那么至此，算是解决了一个冲突，然后重新将文件添加到暂存区<code>git add .</code>然后在提交一个修改<code>git commit</code>，最后来进行一次推送<code>git push</code></p><h3 id="从远端仓库获取最新版本到本地的分支上"><a href="#从远端仓库获取最新版本到本地的分支上" class="headerlink" title="从远端仓库获取最新版本到本地的分支上"></a>从远端仓库获取最新版本到本地的分支上</h3><p><strong>command：</strong></p><p><code>git fetch</code></p><p><strong>explain：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将远端仓库所有分支的最新版版本全部拉取到本地</span></span><br><span class="line">$ git fetch 远端仓库的别名</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将远端仓库指定分支的最新版本拉取回到本地</span></span><br><span class="line">$ git fetch 远程主机名 分支名</span><br></pre></td></tr></table></figure><h3 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h3><p><strong>command：</strong></p><p><code>git merge</code></p><p><strong>explain：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 把指定的分支合并到当前的分支细</span></span><br><span class="line">$ git merge 分支名称</span><br></pre></td></tr></table></figure><h3 id="如何做分支开发"><a href="#如何做分支开发" class="headerlink" title="如何做分支开发"></a>如何做分支开发</h3><p>做分支开发首先需要了解一下几个命令</p><h4 id="操作分支命令"><a href="#操作分支命令" class="headerlink" title="操作分支命令"></a>操作分支命令</h4><p><strong>command：</strong></p><p><code>git branch</code></p><p><strong>explain：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 列出本地所有分支,当前所在分支会通过 " * " 星号标出</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment">// 列出本地所有分支并显示最后一次的提交,当前所在分支会通过 " * " 星号标出</span></span><br><span class="line">$ git branch -v</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新分支,新的分支基于上一次的提交建立</span></span><br><span class="line">$ git branch 分支名</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改分支名称</span></span><br><span class="line"><span class="comment">// 如果不指定原分支名称的话则为当前所在分支</span></span><br><span class="line">$ git branch -m [ 原分支名称 ] 新分支名称</span><br><span class="line"><span class="comment">// 强制修改分支名称</span></span><br><span class="line">$ git branch -M [ 原分支名称 ] 新分支名称</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除指定的本地分支</span></span><br><span class="line">$ git branch -d 分支名称</span><br><span class="line"><span class="comment">// 强制删除指定的本地分支</span></span><br><span class="line">$ git branch -D 分支名称</span><br></pre></td></tr></table></figure><h4 id="检出命令，用于创建、切换分支等"><a href="#检出命令，用于创建、切换分支等" class="headerlink" title="检出命令，用于创建、切换分支等"></a>检出命令，用于创建、切换分支等</h4><p><strong>command：</strong></p><p><code>git checkout</code></p><p><strong>explain：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切换到已存在的指定分支</span></span><br><span class="line">$ git checkout 分支名称</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并切换到指定的分支，保留所有的提交记录</span></span><br><span class="line"><span class="comment">// 等同于 git branch 和 git checkout 两个命令的合并</span></span><br><span class="line">$ git checkout -b 分支名称</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并切换到指定的分支，删除所有的提交记录</span></span><br><span class="line">$ git checkout --orphan 分支名称</span><br><span class="line"></span><br><span class="line"><span class="comment">// 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不会受到影响</span></span><br><span class="line">$ git checkout 文件路径</span><br></pre></td></tr></table></figure><h4 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h4><p>首先需要通过<code>git branch &lt;分支名称&gt;</code>然后来创建一个分支，之后再使用<code>git chankout &lt;分支名称&gt;</code>来切换到一个分支，这个时候可以通过<code>git branch</code>来查看目前是在哪个分支，之后再完成工作的时候，使用<code>git add .</code>将文件添加到暂存区内，然后<code>git commit</code>来提交，然后使用<code>git push</code>进行向远端的推送，这个时候由于远端仓库还不存在这个分支，所以会抛出一个异常：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fatal: The current branch branch1 has no upstream branch.</span><br><span class="line">To push the current branch and <span class="keyword">set</span> the remote as upstream, use</span><br><span class="line"></span><br><span class="line">    git push --<span class="keyword">set</span>-upstream origin branch1</span><br></pre></td></tr></table></figure><p>上面的异常说到<strong>致命：当前分支<code>branch1</code>并没有上游分支</strong>，推送当前分支需要将远端设置为上游，也说了可以使用<code>git push --set-upstream origin branch1</code>，命令会推送到远端，并在远端同时会设置一个分支，名字同样也叫<code>branch1</code>；</p><p>这个时候来查看远端的仓库，会出现一条提示<img src="/2020/04/05/Git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1586083905415.png" class="" title="This is an 1586083905415.png image"></p><p>提示最近推送了一条新的分支，在1分钟前，并且可以对该分支进行<strong>比较并提取请求</strong>；</p><img src="/2020/04/05/Git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/1586083987891.png" class="" title="This is an 1586083987891.png image"><p>同时在<code>Branches</code>中也可以看到刚刚设置的一个新的分支<code>branch1</code>；</p><hr><p>现在再来创建一个新的分支，来模拟合并分支的操作；</p><p>之前已经在另一个目录拉取过仓库了，然后现在把刚刚<code>branch1</code>分支中的新文件复制到这个目录中，并对它进行一些修改；</p><p>然后来执行<code>git checkout -b branch2</code>（创建并切换到这个分支中去），可以通过<code>git branch</code>来查看一下目前是在哪个分支中，然后重复一下上面的操作，将这个分支也推送到远端仓库去；在推送的时候也会抛出异常，说远端不存在该分支，那么可以创建并推送它；</p><h4 id="合并分支-1"><a href="#合并分支-1" class="headerlink" title="合并分支"></a>合并分支</h4><p>其实合作起来，只需要将主要的文件放置在主要分支也就是<code>master</code>中，然后个子开发的时候来创建属于自己的分支，进行开发，在开发完成之后将自己的分支推送到远端的仓库中去，但是目前主分支中是不存在个子开发的内容的，所以需要将所有的分支合并到主分支来，那么就需要通过<code>git merage</code>来对分支进行合并；</p><p>当然在合并之前需要先拉取一下远端的仓库，因为不确定远端仓库和本地仓库中的内容是否一致，不确定远端仓库是否已经被修改了，所以需要先进行同步一下<code>git pull</code>，<strong>这里注意要确定现在自己本地的分支是不是在主要分支上，如果不在需要切换回主分支，<code>git checkout master</code></strong>；在同步完成本地的仓库以后，在进行一次推送，将现在本地的文件推送到主分支去<code>git push</code>；</p><hr><p>此时远端仓库上的<code>master</code>主分支中已经更新了我最新的代码，并且将自己的分支<code>branch1</code>和主分支<code>master</code>进行了合并，也进行了更新，目前远端仓库的<code>master</code>和自己本地仓库中的代码已经完全相同了，之后需要来合并其他人的分支过来，同样也是使用<code>git merge</code>来进行合并，不过需要注意的是；</p><p>如果在你的本地没有要合并的那个分支的话，则会抛出一个异常：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">merge: branch2 - not something we can merge</span><br><span class="line"></span><br><span class="line">Did you mean <span class="keyword">this</span>?</span><br><span class="line">        origin/branch2</span><br></pre></td></tr></table></figure><p>它会告诉你，这是一个不能被合并的分支，因为你的本地是不存在这个分支的，所以需要使用<code>origin/branch2</code>通过远端仓库来进行合并；<code>git merge origin/branch2</code>；</p><p>不过如果两个人开发过程中同时修改了同一个文件的话，合并的过程中就会发成冲突：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFLICT (add/add): Merge conflict <span class="keyword">in</span> branch1.js</span><br><span class="line">Auto-merging branch1.js</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure><p>说到在<code>branch1.js</code>这个文件中出现了冲突，并且自动合并失败了，需要我们来手动修改它的冲突之后在提交结果，也就是在修改完这个冲突之后，在向远端的主要分支<code>master</code>进行合并；</p><hr><p>至此基本的Git使用就结束了，大致的一个思路就是在和几个小伙伴开发的过程中，首先来确定一个主体的东西，比如用哪个框架，框架里需要配置哪些东西等等，之后将这些文件<strong>推送到远端仓库</strong>；</p><p>然后小伙伴们在本地拉取远端仓库中的内容，<strong>并在本地创建一个属于自己的分支</strong>（建议还是不同的人来开发不同的模块，尽量不要让多人修改相同的文件内容），然后在开发完成的时候，由负责人将每个小伙伴的分支合并到主分支也就是<code>master</code>上，就可以了；（最好还是经常性的保证自己本地分支中的一些<code>master</code>分支里的内容与远端仓库中<code>master</code>中的一致）；</p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自用 </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2020/04/05/hello-world/"/>
      <url>/2020/04/05/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HTML-如何理解标签语义化</title>
      <link href="/2019/06/22/HTML-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%A0%87%E7%AD%BE%E8%AF%AD%E4%B9%89%E5%8C%96/"/>
      <url>/2019/06/22/HTML-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E6%A0%87%E7%AD%BE%E8%AF%AD%E4%B9%89%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><ol><li>为了代码结构足够清晰，方便阅读，有利于多人合作的开发；</li><li>方便各种设备和爬虫解析（例如屏幕阅读器，盲人阅读器，移动设备）通过更加语义的方式来渲染页面；</li><li>有利于搜索引擎的优化（SEO）</li><li>在CSS加载慢或加载失败的情况下利于页面布局的展示；</li></ol><a id="more"></a><h2 id="常见的语义化标签："><a href="#常见的语义化标签：" class="headerlink" title="常见的语义化标签："></a>常见的语义化标签：</h2><ul><li><code>title</code>：页面主体内容</li><li><code>h*</code>：从<code>h1~h6</code>分级标题</li><li><code>ul</code>：无序列表</li><li><code>ol</code>：有序列表</li><li><code>nav</code>：导航标签</li><li><code>main</code>：页面主要内容，一个页面最好只使用一次</li><li><code>article</code>：定义外部内容，其中内容独立于文档其他部分</li><li><code>section</code>：定义文档中的节，例如章节、页眉、页脚等等</li><li><code>aside</code>：定义当前内容之外的内。例如侧边栏、一组文章链接、广告、友情链接、相关产品链接等等</li><li><code>footer</code>：页脚，只有父级是<code>body</code>的时候，才能作为整个页面的页脚存在</li><li><code>em</code>：将文本表示为强调的内容</li><li><code>mark</code>：表示突出文本</li><li><code>figure</code>：独立的流内容，图片、图表、照片、代码等等</li><li><code>time</code>：标记文本为日志或时间格式</li><li><code>address</code>：作者、相关人士或组织的联系信息</li><li><code>code</code>：标记代码</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自用 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML-html5新特性</title>
      <link href="/2019/06/22/HTML-html5%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2019/06/22/HTML-html5%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>HTML5</strong>是<code>html</code>标准的增加和更新，包含了一些新的元素标签，属性以及行为事件；</p><p>是为了让Web站点和移动应用更加多样化，功能更加强大的表现；</p><p><strong>HTML5</strong>是这一整套技术更新的统称！</p><a id="more"></a><h2 id="新特性："><a href="#新特性：" class="headerlink" title="新特性："></a>新特性：</h2><ol><li>增加了更多语义化明确的标签，例如<code>header footer nav section article</code>等等；</li><li>离线存储，<code>localStorage 和 sessionStroage</code></li><li>多媒体特性，用于媒体的<code>video 和 audio</code>元素</li><li>图像特性，用于绘制图像的<code>canvas 和 svg</code>元素</li><li>设备访问特性，开放了应用接入开发的接口，像<strong>地理定位</strong>、<strong>拖放API</strong>等等</li><li>连接新特性，主要是<code>WebSocket</code></li><li>性能与集成的特性，用于帮助Web应用或网站可以在更多样的环境中更快速高效的工作</li><li>增强了表单属性</li></ol><h2 id="语义化标签可以查看上一篇文章"><a href="#语义化标签可以查看上一篇文章" class="headerlink" title="语义化标签可以查看上一篇文章"></a>语义化标签可以查看上一篇文章</h2><h2 id="离线存储"><a href="#离线存储" class="headerlink" title="离线存储"></a>离线存储</h2><blockquote><p>HTML5离线存储包含了<strong>应用程序缓存</strong>，<strong>本地存储</strong>，<strong>文件接口</strong></p></blockquote><h3 id="一、应用程序缓存Application-Cache"><a href="#一、应用程序缓存Application-Cache" class="headerlink" title="一、应用程序缓存Application Cache"></a>一、应用程序缓存<code>Application Cache</code></h3><blockquote><p>HTML5通过创建<code>cache manifes</code>文件来创建<code>Web</code>应用的离线存储</p><p>方便了<code>Web</code>应用在没有网络连接时的访问浏览</p></blockquote><p><strong>主要带来了三个优势：</strong></p><ul><li>离线浏览：可以在没有网络连接的时候继续使用应用</li><li>速度：通过缓存加载资源更加快速</li><li>减少服务端压力：对于更新较少不频繁的资源可以缓存在本地，减少与服务端的交互</li></ul>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自用 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
